// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addHealthCheck = `-- name: AddHealthCheck :one
INSERT INTO health_checks (name, url, interval)
VALUES (?, ?, ?)
RETURNING id, name, url, interval, created_at
`

type AddHealthCheckParams struct {
	Name     string
	Url      string
	Interval int64
}

func (q *Queries) AddHealthCheck(ctx context.Context, arg AddHealthCheckParams) (HealthCheck, error) {
	row := q.db.QueryRowContext(ctx, addHealthCheck, arg.Name, arg.Url, arg.Interval)
	var i HealthCheck
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Interval,
		&i.CreatedAt,
	)
	return i, err
}

const addHealthCheckResult = `-- name: AddHealthCheckResult :one
INSERT INTO health_check_results (health_check_id, status, message, checked_at)
VALUES (?, ?, ?, ?)
RETURNING id, health_check_id, status, message, checked_at
`

type AddHealthCheckResultParams struct {
	HealthCheckID int64
	Status        string
	Message       sql.NullString
	CheckedAt     sql.NullTime
}

func (q *Queries) AddHealthCheckResult(ctx context.Context, arg AddHealthCheckResultParams) (HealthCheckResult, error) {
	row := q.db.QueryRowContext(ctx, addHealthCheckResult,
		arg.HealthCheckID,
		arg.Status,
		arg.Message,
		arg.CheckedAt,
	)
	var i HealthCheckResult
	err := row.Scan(
		&i.ID,
		&i.HealthCheckID,
		&i.Status,
		&i.Message,
		&i.CheckedAt,
	)
	return i, err
}

const addProxySite = `-- name: AddProxySite :one
INSERT INTO proxy_sites (container_name, port, domain)
VALUES (?, ?, ?)
    RETURNING id, container_name, port, domain, created_at
`

type AddProxySiteParams struct {
	ContainerName string
	Port          string
	Domain        string
}

func (q *Queries) AddProxySite(ctx context.Context, arg AddProxySiteParams) (ProxySite, error) {
	row := q.db.QueryRowContext(ctx, addProxySite, arg.ContainerName, arg.Port, arg.Domain)
	var i ProxySite
	err := row.Scan(
		&i.ID,
		&i.ContainerName,
		&i.Port,
		&i.Domain,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, hashed_password)
VALUES (?, ?)
RETURNING id, username, hashed_password, totp_secret, created_at, updated_at
`

type CreateUserParams struct {
	Username       string
	HashedPassword string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.HashedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.HashedPassword,
		&i.TotpSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteHealthCheck = `-- name: DeleteHealthCheck :exec
DELETE FROM health_checks WHERE id = ?
`

func (q *Queries) DeleteHealthCheck(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteHealthCheck, id)
	return err
}

const deleteOldHealthChecks = `-- name: DeleteOldHealthChecks :exec
DELETE FROM health_check_results WHERE checked_at < ?
`

func (q *Queries) DeleteOldHealthChecks(ctx context.Context, checkedAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteOldHealthChecks, checkedAt)
	return err
}

const deleteOldLogs = `-- name: DeleteOldLogs :exec
DELETE FROM log_entries WHERE timestamp < ?
`

func (q *Queries) DeleteOldLogs(ctx context.Context, timestamp time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldLogs, timestamp)
	return err
}

const deleteProxySite = `-- name: DeleteProxySite :exec
DELETE FROM proxy_sites WHERE id = ?
`

func (q *Queries) DeleteProxySite(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProxySite, id)
	return err
}

const getContainerLogs = `-- name: GetContainerLogs :many
SELECT container_id, timestamp, message, unique_id, log_level
FROM log_entries
WHERE container_id = ?
ORDER BY timestamp DESC
LIMIT 100
`

type GetContainerLogsRow struct {
	ContainerID string
	Timestamp   time.Time
	Message     string
	UniqueID    string
	LogLevel    string
}

func (q *Queries) GetContainerLogs(ctx context.Context, containerID string) ([]GetContainerLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getContainerLogs, containerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetContainerLogsRow
	for rows.Next() {
		var i GetContainerLogsRow
		if err := rows.Scan(
			&i.ContainerID,
			&i.Timestamp,
			&i.Message,
			&i.UniqueID,
			&i.LogLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredLogs = `-- name: GetFilteredLogs :many
WITH filtered_logs AS (
    SELECT container_id, timestamp, message, unique_id, log_level
    FROM log_entries
    WHERE
        (COALESCE(?3, '') = '' OR container_id IN (?3))
      AND (?4 = '' OR message LIKE '%' || ?4 || '%')
      AND (COALESCE(?5, '') = '' OR log_level IN (?5))
      AND (?6 IS NULL OR timestamp >= ?6)
      AND (?7 IS NULL OR timestamp <= ?7)
)
SELECT
    container_id, timestamp, message, unique_id, log_level,
    (SELECT COUNT(*) FROM filtered_logs) AS total_count
FROM filtered_logs
ORDER BY timestamp DESC
LIMIT ?2 OFFSET ?1
`

type GetFilteredLogsParams struct {
	Offset        int64
	PageSize      int64
	ContainerIds  interface{}
	MessageFilter interface{}
	LogLevels     interface{}
	StartTime     interface{}
	EndTime       interface{}
}

type GetFilteredLogsRow struct {
	ContainerID string
	Timestamp   time.Time
	Message     string
	UniqueID    string
	LogLevel    string
	TotalCount  int64
}

func (q *Queries) GetFilteredLogs(ctx context.Context, arg GetFilteredLogsParams) ([]GetFilteredLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredLogs,
		arg.Offset,
		arg.PageSize,
		arg.ContainerIds,
		arg.MessageFilter,
		arg.LogLevels,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredLogsRow
	for rows.Next() {
		var i GetFilteredLogsRow
		if err := rows.Scan(
			&i.ContainerID,
			&i.Timestamp,
			&i.Message,
			&i.UniqueID,
			&i.LogLevel,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHealthCheckResults = `-- name: GetHealthCheckResults :many
SELECT hcr.health_check_id,
       COUNT(CASE WHEN hcr.status != 'success' THEN 1 END) AS failed_count,
       CASE
           WHEN hcr.health_check_id IN (
               SELECT inner_hcr.health_check_id
               FROM health_check_results inner_hcr
               WHERE inner_hcr.checked_at = (
                   SELECT MAX(inner_most_hcr.checked_at)
                   FROM health_check_results inner_most_hcr
                   WHERE inner_most_hcr.health_check_id = inner_hcr.health_check_id
               )
                 AND inner_hcr.status != 'success'
           ) THEN 1
           ELSE 0
           END AS is_latest_failure
FROM health_check_results hcr
WHERE hcr.checked_at >= ?
GROUP BY hcr.health_check_id
`

type GetHealthCheckResultsRow struct {
	HealthCheckID   int64
	FailedCount     int64
	IsLatestFailure int64
}

// Fix this awful query
func (q *Queries) GetHealthCheckResults(ctx context.Context, checkedAt sql.NullTime) ([]GetHealthCheckResultsRow, error) {
	rows, err := q.db.QueryContext(ctx, getHealthCheckResults, checkedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHealthCheckResultsRow
	for rows.Next() {
		var i GetHealthCheckResultsRow
		if err := rows.Scan(&i.HealthCheckID, &i.FailedCount, &i.IsLatestFailure); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHealthChecks = `-- name: GetHealthChecks :many
SELECT hc.id, hc.name, hc.url, hc.interval, MAX(hcr.checked_at) as last_checked_at
FROM health_checks hc
LEFT JOIN health_check_results hcr ON hc.id = hcr.health_check_id
GROUP BY hc.id, hc.name, hc.url, hc.interval
`

type GetHealthChecksRow struct {
	ID            int64
	Name          string
	Url           string
	Interval      int64
	LastCheckedAt interface{}
}

func (q *Queries) GetHealthChecks(ctx context.Context) ([]GetHealthChecksRow, error) {
	rows, err := q.db.QueryContext(ctx, getHealthChecks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHealthChecksRow
	for rows.Next() {
		var i GetHealthChecksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Interval,
			&i.LastCheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProxySites = `-- name: GetProxySites :many
SELECT id, container_name, port, domain, created_at FROM proxy_sites
`

func (q *Queries) GetProxySites(ctx context.Context) ([]ProxySite, error) {
	rows, err := q.db.QueryContext(ctx, getProxySites)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProxySite
	for rows.Next() {
		var i ProxySite
		if err := rows.Scan(
			&i.ID,
			&i.ContainerName,
			&i.Port,
			&i.Domain,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, hashed_password, totp_secret, created_at, updated_at FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.HashedPassword,
		&i.TotpSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, hashed_password, totp_secret, created_at, updated_at FROM users
WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.HashedPassword,
		&i.TotpSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const saveLog = `-- name: SaveLog :exec
INSERT INTO log_entries (
    container_id, timestamp, message, unique_id, log_level, created_at, updated_at
) VALUES (
             ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
         )
ON CONFLICT(unique_id) DO NOTHING
`

type SaveLogParams struct {
	ContainerID string
	Timestamp   time.Time
	Message     string
	UniqueID    string
	LogLevel    string
}

func (q *Queries) SaveLog(ctx context.Context, arg SaveLogParams) error {
	_, err := q.db.ExecContext(ctx, saveLog,
		arg.ContainerID,
		arg.Timestamp,
		arg.Message,
		arg.UniqueID,
		arg.LogLevel,
	)
	return err
}

const searchLogs = `-- name: SearchLogs :many
SELECT container_id, timestamp, message, unique_id, log_level
FROM log_entries
WHERE message LIKE ?
ORDER BY timestamp DESC
LIMIT 100
`

type SearchLogsRow struct {
	ContainerID string
	Timestamp   time.Time
	Message     string
	UniqueID    string
	LogLevel    string
}

func (q *Queries) SearchLogs(ctx context.Context, message string) ([]SearchLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchLogs, message)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchLogsRow
	for rows.Next() {
		var i SearchLogsRow
		if err := rows.Scan(
			&i.ContainerID,
			&i.Timestamp,
			&i.Message,
			&i.UniqueID,
			&i.LogLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE users
SET hashed_password = ?, updated_at = CURRENT_TIMESTAMP
WHERE username = ?
`

type UpdatePasswordParams struct {
	HashedPassword string
	Username       string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.ExecContext(ctx, updatePassword, arg.HashedPassword, arg.Username)
	return err
}

const updateTotp = `-- name: UpdateTotp :exec
UPDATE users
SET totp_secret = ?, updated_at = CURRENT_TIMESTAMP
WHERE username = ?
`

type UpdateTotpParams struct {
	TotpSecret sql.NullString
	Username   string
}

func (q *Queries) UpdateTotp(ctx context.Context, arg UpdateTotpParams) error {
	_, err := q.db.ExecContext(ctx, updateTotp, arg.TotpSecret, arg.Username)
	return err
}
